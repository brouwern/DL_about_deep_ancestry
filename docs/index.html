<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.45">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Deep Learning about deep ancestry ‚Äì Deep Learning/Deep Ancestry</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Deep Learning/Deep Ancestry</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#consumer-genomics-data" id="toc-consumer-genomics-data" class="nav-link active" data-scroll-target="#consumer-genomics-data">üß¨ Consumer genomics data</a></li>
  <li><a href="#population-genomics-data" id="toc-population-genomics-data" class="nav-link" data-scroll-target="#population-genomics-data">üåç Population genomics data</a></li>
  <li><a href="#machine-learning-and-genomics" id="toc-machine-learning-and-genomics" class="nav-link" data-scroll-target="#machine-learning-and-genomics">ü§ñ Machine learning and genomics</a>
  <ul class="collapse">
  <li><a href="#going-the-distance-with-dna" id="toc-going-the-distance-with-dna" class="nav-link" data-scroll-target="#going-the-distance-with-dna">Going the distance with DNA</a></li>
  <li><a href="#a-picture-is-worth-10000-genome-locations" id="toc-a-picture-is-worth-10000-genome-locations" class="nav-link" data-scroll-target="#a-picture-is-worth-10000-genome-locations">A picture is worth 10,000 genome locations</a></li>
  </ul></li>
  <li><a href="#ancestry-predictions" id="toc-ancestry-predictions" class="nav-link" data-scroll-target="#ancestry-predictions">üìä Ancestry predictions</a></li>
  <li><a href="#delving-deeper-into-ancestry-and-machine-learning" id="toc-delving-deeper-into-ancestry-and-machine-learning" class="nav-link" data-scroll-target="#delving-deeper-into-ancestry-and-machine-learning">Delving deeper into ancestry and machine learning</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Deep Learning about deep ancestry</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><strong>Nathan L. Brouwer, PhD</strong></p>
<section id="genetic-testing-services-use-a-combination-of-advanced-dna-sequencing-and-machine-learning-to-characterize-a-persons-deep-heritage" class="level4">
<h4 class="anchored" data-anchor-id="genetic-testing-services-use-a-combination-of-advanced-dna-sequencing-and-machine-learning-to-characterize-a-persons-deep-heritage">Genetic testing services use a combination of advanced DNA sequencing and machine learning to characterize a person‚Äôs deep heritage</h4>
<p>In the last 20 years, using DNA to charaterize people‚Äôs ancestry has become a <a href="https://www.alumni.hbs.edu/stories/Pages/story-impact.aspx?num=9253">multi-billion dollar industry</a>, with millions of American‚Äôs having had their genomes sequenced by ancestry services like 23andMe and Ancestry.com. People now routinely contemplate results like those in the table below, with their family‚Äôs history rendered with apparent mathematical precision. But how exactly can a small sample of cells in a test-tube be converted to numbers that somehow represent people‚Äôs heritage, ancestry, and parentage?</p>
<div id="dd6eee92" class="cell" data-execution_count="3">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/cell-4-output-1.png" width="651" height="449" class="figure-img"></p>
<figcaption><strong>Example predictions of geographic ancestry.</strong> Predictions were made with a multi-class random forests classifier in scikit-learn.</figcaption>
</figure>
</div>
</div>
</div>
<p>The technology that makes modern genomic ancestry assessment possible is a combination from multiple fields, including advanced DNA sequencing, genome science, and machine learning. While you can‚Äôt sequence your own genome (yet), it takes only a moderate amount of computer programming skills and some open-access data to see how companies like 23andMe and Ancestry.com do their magic.</p>
<p>In this article I will use Python to</p>
<ol type="1">
<li>üß¨ Briefly explains what <strong>raw genomic testing data</strong> looks like</li>
<li>üåç Introduce the types of <strong>population-scale genome data</strong> needed to understand human ancestry</li>
<li>ü§ñ Give an overview of <strong>machine learning models</strong> used in genomics</li>
<li>üìä Show how a person‚Äôs ancestry can be predicted using a machine-learning model</li>
</ol>
<p>Additional articles will present more in depth how these data are processed and results created.</p>
</section>
<section id="consumer-genomics-data" class="level2">
<h2 class="anchored" data-anchor-id="consumer-genomics-data">üß¨ Consumer genomics data</h2>
<p>Direct-to-consumer genomic testing services typically provide a thorough set of results, as well as access to your own raw data. While the reports provided by companies can be <a href="https://customercare.23andme.com/hc/en-us/articles/5328923468183-Understanding-The-Difference-Between-Your-Ancestry-Percentages-Your-Country-Matches-and-Your-Genetic-Groups">very flashy</a>, the raw data for a single person is rather under-whelming, as we can see when its loaded into Python:</p>
<div id="26ff612f" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display" data-execution_count="4">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"># rsid</th>
<th data-quarto-table-cell-role="th">chromosome</th>
<th data-quarto-table-cell-role="th">position</th>
<th data-quarto-table-cell-role="th">genotype</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>rs10034228</td>
<td>4</td>
<td>112611750</td>
<td>CC</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>rs560766</td>
<td>15</td>
<td>35000942</td>
<td>GG</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>rs939661</td>
<td>15</td>
<td>79431063</td>
<td>AG</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>This small snapshot of data is froom 23andMe, but is similar to genomic data from other services as well as that produced by researchers. Each row of these data represent a position in the human genomes where people frequently vary from each other, with the <strong>genotype</strong> indicating what the sequence is for the person‚Äôs DNA being examined. Two letters are shown, one for each of the person‚Äôs parents. ‚ÄúCC‚Äù in the top row means that for this place in the genome, the person recieved a ‚ÄúC‚Äù DNA base from both parents. In contrast, the ‚ÄúAGs‚Äù on the third row indicates that they inherited an ‚ÄúA‚Äù DNA base from one parent and a ‚ÄúG‚Äù from the other. For any given row there are 3 possible combinations of letters that can occur in differnet people. For example, for the AG row, somewhere in the world there are poeple who are AA and others who are GG.</p>
<p>To carry out genomic analyses, these data have to be converted to numbers. For our analysis, we‚Äôll use a simple number system where each of the three combinations that can occur on a row are coded 0, 1 or 2. In the case of the AG rows, ‚ÄúAG‚Äù would be coded as an intermediate value of 1, while AA and GG would be coded as 0 and 2. This results in our snapshot of data looking like this:</p>
<div id="c12357b0" class="cell" data-execution_count="6">
<div class="cell-output cell-output-display" data-execution_count="6">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"># rsid</th>
<th data-quarto-table-cell-role="th">chromosome</th>
<th data-quarto-table-cell-role="th">position</th>
<th data-quarto-table-cell-role="th">genotype</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>rs10034228</td>
<td>4</td>
<td>112611750</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>rs560766</td>
<td>15</td>
<td>35000942</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>rs939661</td>
<td>15</td>
<td>79431063</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>It is important to point out that genomic data is truly ‚Äúbig data‚Äù. For example, data from 23andMe for one person contains over 900,000 rows! This may seem huge, but its actually less than 0.05% of the size of the human genome.</p>
</section>
<section id="population-genomics-data" class="level2">
<h2 class="anchored" data-anchor-id="population-genomics-data">üåç Population genomics data</h2>
<p>In order to characterize someone‚Äôs ancestry we must have a database of many people from around the world to compare them too. While consumer genomics companies have compiled their extensive but proprietery databases, there are also open-access datasets available for anyone to use. The largest public database is the <a href="https://en.wikipedia.org/wiki/1000_Genomes_Project">1000 Genomes Project (1KGP)</a>, which contains genomic information on ~2500 people from 25 populations around the world. 1KGP data has been used in hundreds of scientific papers and can be accessed freely by anyone.</p>
<p>Unfortunately, 1KGP data is a bit unwieldly to access without specialized software; luckily, subsets of the data have been posted by some researchers. In this artile, I‚Äôll use <a href="https://jorde.genetics.utah.edu/published-data/">data</a> provided by researchers from the University of Utah. This study, led by <a href="https://xinglab.genetics.rutgers.edu/people/jinchuan-xing/">Jinchuan Xing</a> and <a href="https://jorde.genetics.utah.edu/">Lynn Jorde</a>, integrated data from the 1000 Genomes Project with data from Jorde‚Äôs lab, resulting in a database of genomic data with 850 people from 40 different populations. For each person in the dataset, they had genomic data similar to that shown above from 23andMe.</p>
<p>After being prepared for analysis, the data from 5 people for 5 places in their genomes would look like the table below. Each person is in a column, and each row contains a number representing their original DNA sequence. In total, Xing and Jorde‚Äôs study. If two people have many of the same values accross the rows, then they are possiblly from the same or similar populations.</p>
<div id="631d3024" class="cell" data-execution_count="7">
<div class="cell-output cell-output-display" data-execution_count="7">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">UID</th>
<th data-quarto-table-cell-role="th">person01</th>
<th data-quarto-table-cell-role="th">person02</th>
<th data-quarto-table-cell-role="th">person03</th>
<th data-quarto-table-cell-role="th">person04</th>
<th data-quarto-table-cell-role="th">person05</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">rs6680471</td>
<td>-0.8</td>
<td>-0.8</td>
<td>-0.8</td>
<td>-0.8</td>
<td>0.6</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">rs3737593</td>
<td>1.6</td>
<td>-0.5</td>
<td>-0.5</td>
<td>3.6</td>
<td>-0.5</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">rs10915495</td>
<td>-0.6</td>
<td>0.8</td>
<td>0.8</td>
<td>0.8</td>
<td>2.3</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">rs639739</td>
<td>1.0</td>
<td>2.6</td>
<td>1.0</td>
<td>-0.6</td>
<td>-0.6</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">rs780587</td>
<td>1.5</td>
<td>1.5</td>
<td>-0.5</td>
<td>-0.5</td>
<td>3.6</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="machine-learning-and-genomics" class="level2">
<h2 class="anchored" data-anchor-id="machine-learning-and-genomics">ü§ñ Machine learning and genomics</h2>
<p>Most machine learning models have applications in population genomics, including dimension reduction, clustering, and supervised classification. Biologists interested in human evolutionar are particularly exploring how Deep Learning methods can reveal insights into human history. While the methods used by consumer genomics companies and researchers are complex and tailored to the complexities of genomic data, we can use ‚Äúoff-the-shelf‚Äù tools from data science and machine learning to understand how more advanced models reach their conclusions.</p>
<p>Regardless of methods, we face two challenges when analyzing genomic data. First, there‚Äôs typically lots of data, with information on hundreds of peole from thousands of places in the genome. Second, each place in the genome serves as a feature (aka variable) of our analysis. In the previous table there were 5 rows and therefore 5 locations in the genome represented. The full dataset has over 10,000 rows.</p>
<section id="going-the-distance-with-dna" class="level3">
<h3 class="anchored" data-anchor-id="going-the-distance-with-dna">Going the distance with DNA</h3>
<p>How do you analyze data with 10,000 features, let alone make a plot representing the data? Analysis of such high-dimensinal data typically requires methods to represent the data in a simpler format, a process known as dimension reduction. One of the easiest method of dimension reduction is to calculate distance between each datapoint. In geometry class we learn to use the Pythagorean Formula to calculate the distance between two points on a sheet of paper. If we had a cruel teacher, we may have had to extend the formula to three dimensions. It turns out that ‚Äì while we can‚Äôt necessarily visualize how it works ‚Äì this formula can be extended beyond three dimensions to four, five, or even 10,000. We can similarly extend what we know about the average of a set of numbers and consider the multidimensional mean of a set of data.</p>
<p>The table below uses this logic to represent the average genetic distance between indvidiauls in major continental groups in Xing and Jorde‚Äôs dataset. First, the average genetic location of people from each continent is determined, and then the distnance between these mean locations calculate.</p>
<p>The largest value in the table is 107 in the Africa-Indigenous Americans rows and columns. The populations of these continents are geographically most distant, and genetically they are, relatively speaking, least similar or ‚Äúmost distant.‚Äù (It is very important add the caveat ‚Äúrelatively‚Äù because two humans are typically 98% the same in terms of DNA, and these numers focus only on the infrequent genetic differenes).</p>
<p>The smallest value on the table is 52, between Europe and Asia. These two continents are geographically contiguous with each other and their populations have remained the most genetically similar (least distant) depsite lignuistic and cultural change.</p>
<div id="bfbf86c1" class="cell" data-execution_count="10">
<div class="cell-output cell-output-display" data-execution_count="10">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Africa</th>
<th data-quarto-table-cell-role="th">Indigenous Americans</th>
<th data-quarto-table-cell-role="th">Asia</th>
<th data-quarto-table-cell-role="th">Europe</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Continental Group</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Africa</td>
<td>0.0</td>
<td>107.0</td>
<td>86.0</td>
<td>90.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Indigenous Americans</td>
<td>107.0</td>
<td>0.0</td>
<td>63.0</td>
<td>79.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Asia</td>
<td>86.0</td>
<td>63.0</td>
<td>0.0</td>
<td>52.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Europe</td>
<td>90.0</td>
<td>79.0</td>
<td>52.0</td>
<td>0.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Once we have characterized the similarities and differences between populations, we can take an individual person‚Äôs DNA sample and compare it to the average locations of each continent. I did this for the DNA sample I introduced at the beginning of this article, and the smallest value is for Europe. This indicats that they are least distant and therefore most similar to the other people in the dataset from this continent.</p>
<div id="90607ca6" class="cell" data-execution_count="11">
<div class="cell-output cell-output-display" data-execution_count="11">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Distance</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Continental Group</th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Africa</td>
<td>149.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Indigenous Americans</td>
<td>143.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Asia</td>
<td>130.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Europe</td>
<td>118.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="a-picture-is-worth-10000-genome-locations" class="level3">
<h3 class="anchored" data-anchor-id="a-picture-is-worth-10000-genome-locations">A picture is worth 10,000 genome locations</h3>
<p>Because it has so many features, genomic data cannot be plotted using standard tools like scatterplots. Once we have a table of genetic distances, though, we can make a plot using the results of a process called NMDS (Non-metric Multi-Dimensonal Scaling).</p>
<p>NMDS turns a distance matrix into a set of x-y coordinates that preserves the relative distances between all sets of points. In the plots</p>
<div id="38795faa" class="cell" data-execution_count="13">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/cell-14-output-1.png" width="604" height="431" class="figure-img"></p>
<figcaption><strong>Relative genetic distances between populations from major continents.</strong> Non-metri multi-dimensional scaling was carried out on a matrix of Euclidean distances</figcaption>
</figure>
</div>
</div>
</div>
<p>There are many machine learning techniques that can be used to visualize high-dimensional genomics data. One of the most common tools used traditionally in population genomics is <strong>Principal Components Analysis</strong> (PCA). PCA is an unsupervised machine learning method which allows high-dimensonal data to be visualized in 2 or 3 dimensions. PCA scatterplots with 2 dimensions are called <strong>biplots</strong>, while those with 3 dimensions are triplots.</p>
<p>In the case of genomic data, information on individual DNA samples enters into the PCA and the lower dimensional data is then plotted. Dat points represent individuals people in the sample, and the points are color-coded based on the geographic location where the individuals are from. This allows PCA to serve as both a visualization and clustering approach.</p>
<p>Additionally, someone whose ancestry is not known or uncertain can have their data transformed by the PCA and plotted along with the other points. The location of the prediction relative to other data points indicates genetic similarity and potentially similar ancestry.</p>
<p>The figure below shows data from Xing and Jorde study discussed above after it has been processed through PCA. The data are color-coded by the large-scale geographic areas the samples are derived from. I then took a <a href="https://github.com/mvolz/osgen/tree/master/sample%20genomes">23andMe record</a> for a person with unknown ancestry and used my PCA model to estimate which samples from Xing this person is most similar to. Based on their location, they are most likely predominantly European ancestry.</p>
<div id="a7f505a5" class="cell" data-execution_count="15">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/cell-16-output-1.png" width="617" height="449" class="figure-img"></p>
<figcaption>Principal Components Analysis (PCA) biplot showing the location (X) of a sample with uncertain ancestry. Based on its location, it can be inferred that this person is likely to be of predominantly European ancestry.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="ancestry-predictions" class="level2">
<h2 class="anchored" data-anchor-id="ancestry-predictions">üìä Ancestry predictions</h2>
<p>PCA biplots are ubiquitous in scientific papers on population genomics and ancestry, often as a central figure. Consumer genetic companies, however, typically focus their results on assignment to one or more ancestry categories. We can carry out a similar assignment, known technically a multi-class classification, using standard tools in Python. In this Analysis, used a Random-forests classifier to gauge the relative probability that the person‚Äô whose DNA sequence we‚Äôve been working with fit into 1 of 7 possible geographic groups.</p>
<div id="3ed68639" class="cell" data-execution_count="16">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/cell-17-output-1.png" width="648" height="449" class="figure-img"></p>
<figcaption><strong>Examples predictions of geographic ancestry.</strong> Predictions were made with a multi-class random forests classifier in scikit-learn.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="delving-deeper-into-ancestry-and-machine-learning" class="level2">
<h2 class="anchored" data-anchor-id="delving-deeper-into-ancestry-and-machine-learning">Delving deeper into ancestry and machine learning</h2>
<p>The data and analyzes presented in this article should give you a sense for how consumer genomics companies are able to transform a sample of spit or cheek cells into a prediction about someone‚Äôs ancestry. Companies like 23andMe and Ancestry.com now how millions of people in their databases, reference samples from dozens of populations, and machine-learning and deep-learning algorithms tailored to their specific goals. Similar predictions about a person‚Äôs ancestry can be reached using standard machine learning tools. This makes genomic data an excellent place for data scientists explore and test different methods.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>